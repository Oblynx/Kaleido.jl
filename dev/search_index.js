var documenterSearchIndex = {"docs":
[{"location":"#Kaleido.jl-1","page":"Home","title":"Kaleido.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"index.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Kaleido","category":"page"},{"location":"#Kaleido","page":"Home","title":"Kaleido","text":"Kaleido: some useful lenses\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: Coveralls)\n\nKaleido.jl is a collection of useful Lenses that enhance Setfield.jl.\n\njulia> using Setfield, Kaleido\n\njulia> lens = @batchlens begin\n           _.a.b.c\n           _.a.b.d[1]\n           _.a.b.d[3] ∘ to𝕀\n           _.a.e\n       end;\n\njulia> obj = (a = (b = (c = 1, d = (2, 3, 0.5)), e = 5),);\n\njulia> get(obj, lens)\n(1, 2, 0.0, 5)\n\njulia> set(obj, lens, (10, 20, Inf, 50))\n(a = (b = (c = 10, d = (20, 3, 1.0)), e = 50),)\n\njulia> ml = MultiLens((\n           (@lens _.x),\n           (@lens _.y.z) ∘ toℝ₊,\n       ));\n\njulia> @assert get((x=1, y=(z=1.0,)), ml) == (1, 0.0)\n\njulia> @assert set((x=1, y=(z=2,)), ml, (\"x\", -1)) == (x=\"x\", y=(z=exp(-1),))\n\njulia> l = MultiLens((\n           (@lens _.x) ∘ IndexBatchLens(:a, :b, :c),\n           (@lens _.y) ∘ IndexBatchLens(:d, :e),\n       )) ∘ FlatLens(3, 2);\n\njulia> @assert get((x=(a=1, b=2, c=3), y=(d=4, e=5)), l) === (1, 2, 3, 4, 5)\n\njulia> @assert set((x=(a=1, b=2, c=3), y=(d=4, e=5)), l, (10, 20, 30, 40, 50)) ===\n           (x=(a=10, b=20, c=30), y=(d=40, e=50))\n\nKaleido.jl also works with AbstractTransform defined in TransformVariables.jl:\n\njulia> using Setfield, Kaleido, TransformVariables\n\njulia> l = (@lens _.y[2]) ∘ BijectionLens(as𝕀);\n\njulia> obj = (x=0, y=(1, 0.5, 3));\n\njulia> @assert get(obj, l) == 0\n\njulia> @assert set(obj, l, Inf).y[2] ≈ 1\n\n\n\n\n\n","category":"module"},{"location":"#Setting/getting-multiple-locations-1","page":"Home","title":"Setting/getting multiple locations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Kaleido.@batchlens\nKaleido.batch\nKaleido.MultiLens\nKaleido.PropertyBatchLens\nKaleido.KeyBatchLens\nKaleido.IndexBatchLens\nKaleido.FlatLens","category":"page"},{"location":"#Kaleido.@batchlens","page":"Home","title":"Kaleido.@batchlens","text":"@batchlens begin\n    lens_expression_1\n    lens_expression_2\n    ...\n    lens_expression_n\nend\n\nExamples\n\njulia> using Kaleido, Setfield\n\njulia> lens = @batchlens begin\n           _.a.b.c\n           _.a.b.d\n           _.a.e\n       end;\n\njulia> obj = (a = (b = (c = 1, d = 2), e = 3),);\n\njulia> get(obj, lens)\n(1, 2, 3)\n\njulia> set(obj, lens, (10, 20, 30))\n(a = (b = (c = 10, d = 20), e = 30),)\n\n\n\n\n\n","category":"macro"},{"location":"#Kaleido.batch","page":"Home","title":"Kaleido.batch","text":"batch(lens₁, lens₂, ..., lensₙ) :: Lens\n\nFrom n lenses, create a single lens that gets/sets n-tuple in such a way that the number of call to the constructor is minimized. This is done by calling IndexBatchLens whenever possible.\n\n\n\n\n\n","category":"function"},{"location":"#Kaleido.MultiLens","page":"Home","title":"Kaleido.MultiLens","text":"MultiLens([castout,] lenses::Tuple)\nMultiLens([castout,] lenses::NamedTuple)\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> ml = MultiLens((\n           (@lens _.x),\n           (@lens _.y.z),\n       ));\n\njulia> @assert get((x=1, y=(z=2,)), ml) === (1, 2)\n\njulia> @assert set((x=1, y=(z=2,)), ml, (\"x\", \"y.z\")) === (x=\"x\", y=(z=\"y.z\",))\n\njulia> ml = MultiLens((\n           a = (@lens _.x),\n           b = (@lens _.y.z),\n       ));\n\njulia> @assert get((x=1, y=(z=2,)), ml) === (a=1, b=2)\n\njulia> @assert set((x=1, y=(z=2,)), ml, (a=:x, b=\"y.z\")) === (x=:x, y=(z=\"y.z\",))\n\njulia> @assert set((x=1, y=(z=2,)), ml, (b=\"y.z\", a=:x)) === (x=:x, y=(z=\"y.z\",))\n\njulia> using StaticArrays\n\njulia> ml = MultiLens(\n           SVector,\n           (\n               (@lens _.x),\n               (@lens _.y.z),\n           )\n       );\n\njulia> @assert get((x=1, y=(z=2,)), ml) === SVector(1, 2)\n\n\n\n\n\n","category":"type"},{"location":"#Kaleido.PropertyBatchLens","page":"Home","title":"Kaleido.PropertyBatchLens","text":"PropertyBatchLens(names)\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> lens = PropertyBatchLens(:a, :b, :c);\n\njulia> @assert get((a=1, b=2, c=3, d=4), lens) == (a=1, b=2, c=3)\n\njulia> @assert set((a=1, b=2, c=3, d=4), lens, (a=10, b=20, c=30)) ==\n           (a=10, b=20, c=30, d=4)\n\n\n\n\n\n","category":"type"},{"location":"#Kaleido.KeyBatchLens","page":"Home","title":"Kaleido.KeyBatchLens","text":"KeyBatchLens(names)\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> lens = KeyBatchLens(:a, :b, :c);\n\njulia> @assert get((a=1, b=2, c=3, d=4), lens) == (a=1, b=2, c=3)\n\njulia> @assert set((a=1, b=2, c=3, d=4), lens, Dict(:a=>10, :b=>20, :c=>30)) ==\n           (a=10, b=20, c=30, d=4)\n\n\n\n\n\n","category":"type"},{"location":"#Kaleido.IndexBatchLens","page":"Home","title":"Kaleido.IndexBatchLens","text":"IndexBatchLens(names)\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> lens = IndexBatchLens(:a, :b, :c);\n\njulia> @assert get((a=1, b=2, c=3, d=4), lens) == (1, 2, 3)\n\njulia> @assert set((a=1, b=2, c=3, d=4), lens, (10, 20, 30)) ==\n           (a=10, b=20, c=30, d=4)\n\n\n\n\n\n","category":"type"},{"location":"#Kaleido.FlatLens","page":"Home","title":"Kaleido.FlatLens","text":"FlatLens(N₁, N₂, ..., Nₙ)\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> l = MultiLens((\n           (@lens _.x) ∘ IndexBatchLens(:a, :b, :c),\n           (@lens _.y) ∘ IndexBatchLens(:d, :e),\n       )) ∘ FlatLens(3, 2);\n\njulia> @assert get((x=(a=1, b=2, c=3), y=(d=4, e=5)), l) === (1, 2, 3, 4, 5)\n\njulia> @assert set((x=(a=1, b=2, c=3), y=(d=4, e=5)), l, (10, 20, 30, 40, 50)) ===\n           (x=(a=10, b=20, c=30), y=(d=40, e=50))\n\n\n\n\n\n","category":"type"},{"location":"#Bijective-transformations-as-lenses-1","page":"Home","title":"Bijective transformations as lenses","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Kaleido.BijectionLens\nKaleido.toℝ₊\nKaleido.toℝ₋\nKaleido.to𝕀","category":"page"},{"location":"#Kaleido.BijectionLens","page":"Home","title":"Kaleido.BijectionLens","text":"BijectionLens(fromfield, tofield) :: Lens\nBijectionLens(xf::TransformVariables.AbstractTransform) :: Lens\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> l = (@lens _.y[2]) ∘ BijectionLens(x -> x/2, x -> 2x);\n\njulia> obj = (x=0, y=(1, 2, 3));\n\njulia> @assert get(obj, l) == 1.0 == 2/2\n\njulia> @assert set(obj, l, 0.5) == (x=0, y=(1, 1.0, 3))\n\njulia> using Setfield, Kaleido, TransformVariables\n\njulia> l = (@lens _.y[2]) ∘ BijectionLens(as𝕀);\n\njulia> obj = (x=0, y=(1, 0.5, 3));\n\njulia> @assert get(obj, l) == 0\n\njulia> @assert set(obj, l, Inf).y[2] ≈ 1\n\njulia> @assert set(obj, l, -Inf).y[2] ≈ 0.0\n\n\n\n\n\n","category":"type"},{"location":"#Kaleido.toℝ₊","page":"Home","title":"Kaleido.toℝ₊","text":"toℝ₊ :: BijectionLens\n\nThis is a stripped-down version of BijectionLens(TransformVariables.asℝ₊) that works without TransformVariables.jl.\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> l = (@lens _.y[2]) ∘ toℝ₊;\n\njulia> obj = (x=0, y=(0, 1, 2));\n\njulia> @assert get(obj, l) == 0.0 == log(obj.y[2])\n\njulia> @assert set(obj, l, -1) == (x=0, y=(0, exp(-1), 2))\n\n\n\n\n\n","category":"constant"},{"location":"#Kaleido.toℝ₋","page":"Home","title":"Kaleido.toℝ₋","text":"toℝ₋ :: BijectionLens\n\nThis is a stripped-down version of BijectionLens(TransformVariables.asℝ₋) that works without TransformVariables.jl.\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> l = (@lens _.y[2]) ∘ toℝ₋;\n\njulia> obj = (x=0, y=(0, -1, 2));\n\njulia> @assert get(obj, l) == 0.0 == log(-obj.y[2])\n\njulia> @assert set(obj, l, 1) == (x=0, y=(0, -exp(1), 2))\n\n\n\n\n\n","category":"constant"},{"location":"#Kaleido.to𝕀","page":"Home","title":"Kaleido.to𝕀","text":"to𝕀 :: BijectionLens\n\nThis is a stripped-down version of BijectionLens(TransformVariables.as𝕀) that works without TransformVariables.jl.\n\nExamples\n\njulia> using Setfield, Kaleido\n\njulia> l = (@lens _.y[2]) ∘ to𝕀;\n\njulia> obj = (x=0, y=(0, 0.5, 2));\n\njulia> @assert get(obj, l) == 0.0\n\njulia> @assert set(obj, l, Inf).y[2] ≈ 1\n\njulia> @assert set(obj, l, -Inf).y[2] ≈ 0\n\n\n\n\n\n","category":"constant"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Modules = [Kaleido]\nPublic = false","category":"page"},{"location":"internals/#Kaleido.KaleidoLens","page":"Internals","title":"Kaleido.KaleidoLens","text":"KaleidoLens <: Lens\n\nInternal abstract type for Kaleido.jl.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Kaleido.SingletonLens","page":"Internals","title":"Kaleido.SingletonLens","text":"SingletonLens()\n\nInverse of FlatLens(1).\n\n\n\n\n\n","category":"type"},{"location":"internals/#Kaleido._compose-Tuple{Setfield.Lens,Setfield.Lens}","page":"Internals","title":"Kaleido._compose","text":"_compose(lens1, lens2)\n\nLike ∘ but fixes the associativity to match with the default one in Setfield.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Kaleido.prefer_singleton_callable-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"Kaleido.prefer_singleton_callable","text":"prefer_singleton_callable(f)\n\nConvert f to an callable singleton object if possible.  Useful if f is a Type.\n\nExamples\n\njulia> using Kaleido: prefer_singleton_callable\n\njulia> sizeof((Int,))\n8\n\njulia> sizeof((prefer_singleton_callable(Int),))\n0\n\njulia> prefer_singleton_callable(Int)(1.0)\n1\n\n\n\n\n\n","category":"method"}]
}
